<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS2-2. 바(var), 렛(let), 콘스트(const)</title>
    <script>
        /****************************************************************
            변수는 바.렛.콘스트


            [ var ] : 함수영역변수
            1. 함수영역에서 사용할 때만 지역변수
            2. 함수영역 바깥에서 쓰면 전역변수
            3. 전역변수와 같은 이름의 변수를 함수내에서 값을 할당하면 덮어쓰기가 됨
            4. 함수영역에서 전역변수와 같은 이름의 변수를 선언하면 전역변수와 다른 지역변수로 관리됨
                (이렇게 하면 코딩이 매우 혼란스러워질 수 있음)
                또는 변수이름이 같은 이름이지만 지역변수로 사용할 수 있다는 장점이 되기도 함

            ______________________________________

            ( 지역변수 - local variable )
            함수영역 내에 선언한 변수
            - 특징: 다른 함수나 바깥 전역영역에서 지역변수를 참조할 수 없다(사용할 수 없다.)

            ( 전역변수 - global variable )
            함수밖 영역에서 선언한 변수
            - 특징: 어떤 함수에서도 전역변수를 참조할 수 있다.
            ->>> 즉, 전역변수의 값도 변경할 수 있다.
            -> 전역변수는 공유하고자 하는 데이터를 저장할 때 사용함



            [ let ] : 블여영역변수(중괄호는 모두 블록임)
            1. let으로 변수를 선언하면 전역과 지역을 별도로 관리하여 같은이름의 변수도 별개의 변수로 인식함
            2. let변수는 선언 후 아래쪽에서 사용해야만 함 -> 변수 hoisting 금지
                (비교: var는 위에서 호출하고 아래에서 선언할 수 있음 - 변수의 hoisting)
            3. 같은 영에에서 같은 이름의 변수를 중복선언할 수 없다
                (비교: var는 중복선언시 덮어씀 - 재선언가능)
            



            [ const ] : 상수(constant) -> 변하지 않는값
            1. 선언과 동시에 할당해야함!
            2. 한번 할당한 값은 변경불가!
            3. 배열과 객체, 함수를 상수로 만드는 경우가 많다!
                -> 변경불가는 각 배열형, 객체형, 함수형
                -> 변경가능은 각 배열값, 객체값, 함수전달값
            4. 기타의 특징은 let과 동일함!(블록단위변수)



        ****************************************************************/

       ///////////////////////////////////////////////////////
       //////////////////////// var 테스트 ////////////////////
       //////////////////////////////////////////////////////
        
       /* JS에서 중괄호{}란? */
       /* 1. 함수 중괄호에서 var */
        function callMe(){
           /* 함수 내에서 변수를 선언하면 지역변수 */
            var usa = "미국";
            
            console.log('3. 함수안 지역 usa: ', usa);
            
            /* 함수 내에서 전역변수 korea값 변경 */
            korea = "코리아"
            console.log('4. 함수안 전역 korea: ', korea);
            console.log('5 .함수안 전역 uk: ', uk);
            
            /* 전역변수에 선언된 uk변수와 같은 이름의 지역변수만들기 */
            /* 아래쪽에 같은 이름의 지역 uk를 만드는 순간 이 변수는 지역변수로 취급된다 */
            /* ->>> 전역변수 uk와는 영영 이별함 */
            /* 결과는 undefined -> 지역 uk 변수가 할당되기 전에 출력됨 */
            var uk = "유케이";
            console.log('6 .함수안 지역 uk: ', uk);
            
            /* 선언한적이 없는 변수를 바로 사용해보자 */
            rabbit = "토끼";
            console.log('7. 함수안 선언없는 rabbit: ', rabbit);
            
            
        }//⁡⁢⁣############## callMe 함수 ###############⁡
        
        /* 함수 바깥에서 변수를 선언하면 전역변수 */
        var korea = "한국";
        var uk = "영국";
        
        console.log('1. 함수밖 전역 korea: ', korea);
        console.log('2. 함수밖 전역 uk: ', uk);
        
        /* callMe 함수 호출 */
        callMe();
        
        /* 함수에서 전역변수값을 변경하였음 */
        console.log('8. 함수밖 전역 korea: ', korea);
        
        /* 함수안에서 선언없이 할당한 변수 rabbit 바깥에서 찍기 */
        console.log('9. 함수밖 선언없는 rabbit: ', rabbit);
        /* -> 선언없이 지역에서 할당한 변수는 전역에 등록됨 -> 변수 관리가 어려워지고 나중에 소스관리에 리스크가 생김 */
        /* ⁡⁢⁣⁢선언없이 변수를 사용하지 말라 -> w3c, JS업데이트팀에서 권고 사항⁡ */

        /* 지역변수를 전역에서 참조 불가 - 에러남 */
        // console.log('함수밖 지역 usa: ', usa);

        /* 1. if문에서 중괄호 var */
        if(true){
            var who = "누구?";
            console.log('if문 안 who: ', who);
        }
        console.log('if문 밖 who: ', who);
        /* if문의 중괄호 안에서 변수를 선언하면 전역변수와같다 -> 즉, 중괄호가 지역역할을 못함 */
        
        
        /* 1. if문에서 중괄호 let 비교*/
        if(true){
            let what = "뭣이?";
            console.log('if문 안 what: ', what);
        }
        // console.log('if문 밖 what: ', what);
        /* if문의 중괄호 안의 let는 지역변수이므로 바깥에서 못씀*/


        /* 3. for문 중괄호 var */
        for(var i = 3; i>0; i--){
            console.log("for문안 i: ", i);
        }
        console.log("for문밖 i: ", i);
        /* for문의 중괄호도 지역역할 하지 못함 */
        /* 결론 ->>>>>>>>> var는 오직 함의의 중괄호에서만 선언시 지역변수가 된다. */


        /* 3. for문 중괄호 let 비교 */
        for(let j = 3; j>0; j--){
            console.log("for문안 j: ", j);
        }
        // console.log("for문밖 j: ", j);
        /* for문의 소괄호 세팅은 중괄호 안으로 들어가므로 let변수 선언시  for중괄호 안에 선언으로 처리됨 */
        /* -> 따라서 지역변수로 처리됨 */
        
        ///////////////////////////////////////////////////////
        ///////////////// let, const 테스트 ////////////////////
        //////////////////////////////////////////////////////

        var seoul = "서울";
        var jeju = "제주";
        let toktok = "카톡";
        let sport = "축구";
        
        /********************* 중괄호로 블록영역 만듦 *********************/
        ///////////////////////////////////////////////////////////////
        {
            /* 블록 내부에서 전역변수 찍기 앞 */
            console.log("블록 내부에서 전역변수 찍기 앞");
            console.log("seoul: ", seoul);

            /* 블록에서 변수 재선언하기 */
            var seoul= "강남구";
            /* 하단에서 전역으로 변수를 다시 선언할당한 결과 */

            // console.log('jeju: ', jeju);
            /* let으로 선언한 변수는 선언전 사용불가 - Uncaught ReferenceError: Cannot access 'jeju' ⁡⁣⁣⁢before initialization⁡ */

            /* let으로 지역변수 jeju 선언 */
            let jeju = "마라도";
            /* 중괄호 안의 let은 지역변수를 생성함 */
            console.log('jeju: ', jeju);

            /* 전역변수 let으로 선언된 같은이름의 변수 만들기 */
            let toktok = "라인";
            /* 중괄호 바깥의 let변수와 구분함 */
            /* 지역변수로 사용됨 */

            console.log('toktok: ', toktok);
            
            
            /* var로 전역변수의 let변수를 다시 선언하기 */
            // var sport = "배구";
            /* 전역에 선언된 let과 같은 이름으로 두번 변수를 선언할 수 없도록 막아줌 - Uncaught SyntaxError: Identifier 'sport' ⁡⁣⁣⁢has already been declared⁡ */
            console.log('sport: ', sport);


            /* 선언하지 않은 변수를 할당하기 */
            myitem = "곰인형";
            console.log('myitem: ', myitem);
            /* 기본적으로 선언없이 사용한 변수는 var로 전역변수 선언된다 -> 함수안에서도 마찬가지 */
            /* 변수에 대한 관리가 어려워짐 */
            
            ///////////////////////////////    
            
            /* 블록 내부에서 전역변수 찍기 뒤 */
            console.log("블록 내부에서 전역변수 찍기 뒤");
            console.log("seoul: ", seoul);
            console.log('jeju: ', jeju);
            console.log('toktok: ', toktok);
            console.log('sport: ', sport);
            //////////////////////////////
        }
        ///////////////////////////////////////////////////////////////
        
        /* 블록 외부에서 전역변수 찍기 */
        console.log("블록 외부에서 전역변수 찍기");
        console.log("seoul: ", seoul);
        console.log('jeju: ', jeju);
        console.log('toktok: ', toktok);
        console.log('sport: ', sport);
        console.log('myitem: ', myitem);
        //////////////////////////////
        
        

        /*/////////////// 변수 hoisting(Variable Hoisting) ///////////////*/
        cat = "고양이"; //선 변수할당
        console.log('cat: ', cat);
        var cat;    //후 변수선언
        /* 위에서 변수에 uk의 경우와 마찬가지 */
        /* 변수선언을 아래에서 하는 허용은 var에서만 가능 -> 코딩순서의 혼란을 야기함*/
        
        /* let은 변수 hoisting을 허용하지 않음 - Uncaught ReferenceError: Cannot access 'dog' ⁡⁣⁣⁢before initialization⁡*/
        dog = "강아지";
        console.log('dog: ', dog);
        // let dog;
        // -> 변수의 선언과 할당에 대한 철저한 순서를 지킬 수 있음
        // -> var를 사용하지 않는 중요한 이유중 하나임

        var cat ="먼치킨";
        console.log('cat: ', cat);
        /* var는 재선언 가능함 */

        // let dog = "시바견";
        /* let은 재선언이 불가능함 -> let을 쓰는 이유중 하나 */

        /*///////////////////// 상수테스트 /////////////////////*/
        // const fish;
        // fish = "고등어" -> 동시선언 에러남;

        const fish = "고등어";
        console.log('상수 fish: ', fish);
        /* 원칙1: 상수는 선언과 동시에 할당해야함 */
        // fish = "참치" -> 재할당 에러
        /* 원칙2: 상수는 재할당이 불가능 - Uncaught TypeError: ⁡⁣⁣⁢Assignment to constant variable.⁡*/

        /* 상수는 배열, 객체, 함수를 할당하여 많이 사용함 */

        /////////////////////////////////////////////
        //////////// const의 활용: 배열, 객체, 함수//////
        /////////////////////////////////////////////

        /* 1. 배열 */
        const arr = ["상추", "고기", "마늘"];
        console.log('배열 arr값: ', arr);

        /* 재할당 시도시 에러남 - ㄷ */
        // arr = "닭고기";

        /* 배열값 추가 */
        arr.push("닭고기");
        console.log('배열 arr값: ', arr);

        /* 배열값은 변경가능 그러나 새로운 데이터 할당은 불가능 */

        /* 2. 객체 */
        const obj = {name : "김수현"};
        console.log('객체 obj: ', obj);
        
        /* 재할당 불가 */
        // obj = 100;
        
        /* 객체 속성 추가하기 */
        /* 추가 방법: object객체의 속성정의메 메서드 사용 */
        /* -> Object.defineProperty(객체명, 속성명, {value:속성값}) */
        Object.defineProperty(obj,"weight",{value:"76kg"});
        console.log('객체 obj: ', obj);


        /* 3. 함수 */
        const fn = function(txt){
            console.log("나야나", txt);
        };
        /* 함수호출 */
        fn("화이팅");

        /* 그 밖에 배열, 객체, 함수 외에 요소를 담을 경우에도 많이 사용된다. */
        /* 사용이유는? 실수로 재할당될 위험에서 지키기 위함 또는 보안상 이유로 많이 사용된다. */


        
        /********************************************** 
            ※ 정리 :
            ________________________________

            배열값 설정
            const 변수명 = [값1,값2,...];
            _________________________________

            배열값 호출
            변수명[순번] -> 순번은 0부터
            _________________________________

            객체값 설정
            const 변수명 = {속성:값,속성:값,...}
            ___________________________________

            객체값 호출

            변수명[속성명]
            -> 속성명을 따옴표로 싼 문자형임
            (만약 변수형 속성명이어도 이렇게 부를땐
            따옴표로 반드시 싸야한다!)

            또는

            변수명.속성명
            -> 속성명이 반드시 변수형 이어야함!
            -> 속성명이 문자형이어도 변수형에 적합하면 이와같이 사용가능

            ____________________________________

            참고) 내장객체를 new키워드 없이 바로 할당하는
            방식을 리터럴이라고 부른다 -> 리터럴 방식을 추천
            예) let str = ""  /  let str = new String();
                let arr = []  /  let arr = new Array();
                let obj = {}  /  let obj = new Object();

        *********************************************/




        </script>
</head>
<body>
    
</body>
</html>