"use strict";
/* 메뉴관련 데이터 JS - mdata.js */
/*
    [ 데이터 구조 ]
    상위메뉴:{
        하위메뉴:[서브1, 서브2, 서브3, ...],
        하위메뉴:[서브1, 서브2, 서브3, ...],
    }
*/
const mdata = {
    "Only시코르": {
        "오노마": ["에센스", "스킨/토너", "크림", "선크림", "세트"],
        "시코르 컬렉션": ["시코르 스킨케어", "시코르 메이크업", "시코르 바디", "시코르 뷰티툴"],
        "미니 시코르": ["메이크업", "스킨케어", "헤어/바디"]
    },
    "스킨케어": {
        "페이셜케어": ["스킨/토너", "로션", "에센스/세럼", "크림/젤/밤", "아이케어", "오일", "미스트", "세트"],
        "클렌징": ["클렌징워터/오일", "클렌징젤/폼/솝", "클렌징밀크/크림/밤", "아이/립 리무버", "클렌징티슈/패드", "스크럽/필링", "클렌징/마사지기기"],
        "마스크/팩": ["시트마스크", "워시오프팩", "슬리핑팩", "부분 패치"],
        "선케어": ["선크림", "선쿠션", "선스틱/스프레이"]
    },
    "메이크업": {
        "베이스메이크업": ["프라이머/베이스", "BB/CC", "파운데이션", "쿠션", "컨실러", "파우더", "메이크업픽서"],
        "립메이크업": ["립스틱", "립틴트/락커", "립글로스", "립펜슬/립라이너", "립에센스/립밤"],
        "아이메이크업": ["아이라이너", "아이브로우", "아이섀도우/팔레트", "마스카라", "아이프라이머", "아이래쉬/속눈썹영양제"],
        "블러셔/하이라이터/쉐딩": ["블러셔/치크", "하이라이터", "쉐딩/컨투어링"],
        "네일케어": ["네일 폴리쉬", "젤 네일 폴리쉬", "베이스/탑코트", "네일팁/스티커", "리무버/영양제"]
    },
    "맨즈케어": {
        "쉐이빙/클렌징": ["폼/젤/크림", "애프터쉐이브", "올인원"],
        "페이셜케어": ["스킨/토너", "로션/크림/올인원", "에센스/세럼", "마스크/팩", "선케어", "세트"],
        "메이크업": ["베이스/BB/CC", "립밤/립틴트"]
    },
    "바디케어": {
        "바디워시": ["바디클렌저/비누", "바디스크럽", "입욕제", "여성청결제"],
        "바디보습": ["바디로션", "바디크림/젤/밤", "바디오일/에센스", "바디미스트"],
        "핸드/풋": ["핸드워시", "핸드크림/밤", "세니타이저", "풋크림", "발관련용품"],
        "기능성 바디": ["슬리밍/탄력", "임산부/튼살"],
        "베이비/키즈": ["워시", "로션/크림", "오일/파우더", "선케어", "립케어", "네일/마스크팩", "세트"],
        "데오드란트/제모": ["스프레이", "스틱/롤온", "제모용품"],
        "덴탈케어": ["치약", "칫솔", "가글용품/구취제거제", "치아미백제/치실", "세트"]
    },
    "향수": {
        "향수": ["여성향수", "남성향수", "스틱/롤온", "인센스", "향초/디퓨저/방향제"]
    },
    "헤어케어": {
        "샴푸/린스/트리트먼트": ["샴푸/린스", "트리트먼트/헤어팩", "세트"],
        "염모제": ["염색"],
        "헤어스타일링": ["드라이샴푸", "헤어에센스/오일", "헤어젤/스프레이/무스", "헤어왁스/포마드", "헤어미스트"],
        "헤어기기": ["드라이기", "헤어 아이론"]
    },
    "웰니스☘": {
        "힐링케어": ["아로마 오일", "바디테라피", "인센스", "디퓨저/캔들"],
        "이너뷰티": ["유산균"],
        "페미닌케어": ["페미닌케어"]
    },
    "뷰티툴": {
        "페이스소품": ["메이크업브러시", "스펀지/퍼프", "브러시/퍼프 클렌저", "화장솜", "면봉"],
        "아이 소품": ["눈썹손질도구/족집게", "뷰러/고데기", "속눈썹", "쌍꺼풀"],
        "네일소품": ["네일 도구"],
        "바디소품": ["샤워용품", "클렌징도구"],
        "헤어소품": ["헤어브러쉬", "헤어액세서리", "헤어롤"],
        "기타화장소품": ["거울", "파우치", "기타"],
        "잡화": ["잡화", "마스크"]
    }
};
// window.addEventListener("DOMContentLoaded", ()=>{
//     /* 최상위 배너박스 선정 : .banbx*/
//     const banbx = document.querySelectorAll(".banbx")
//     /* banbx  일괄 세팅하기 */
//     banbx.forEach((ele, idx)=>setBan(ele, idx));
// });
// /***************************************************
//     [ 배너함수 다중배너 세팅함수로 모듈화 하기 ]
//     -> 전달값을 사용하여 개별적인 배너요소 하위의 기능으로 작동하도록 최상위 배열요소를 함수로 전달하여
//     내부 기능세팅시 document로 선택했던 요소를 모두 개별 최상위 배너요소의 하위요소 선택으로 변경하면
//     기존 변수 세팅을 그대로 사용하여 개별 배너 모듈화를 손쉽게 할 수 있다.
//     [ 모듈화 원칙 ]
//     1. 상대적인 선택자 사용
//     2. for문에 의한 개별요소별 일괄세팅
//     3. 구체적인 차이점은 전달 변수를 통하여 해결
// ***************************************************/
// /***************************************************** 
//     [ 슬라이드 이동 기능정의 ]
//     1. 이벤트 종류: click
//     2. 이벤트 대상: 이동버튼(.abtn)
//     3. 변경 대상: 슬라이드 박스(.slide)
//     4. 기능 설계:
//         -> left 이동의 기준값이 -220% 인것이 포인트
//         (이유: 2장의 슬라이드가 앞에 나가있음. 잘라내는 것이 숨겨져야 함)
//         (1) 오른쪽 버튼 클릭시 다음 슬라이드가
//             나타나도록 슬라이드 박스의 left값을
//             -330%로 변경시킨다.
//             -> 슬라이드 이동후!!! 
//             바깥에 나가있는 첫번째 슬라이드
//             li를 잘라서 맨뒤로 보낸다!
//             동시에 left값을 0으로 변경한다!
//         (2) 왼쪽버튼 클릭시 이전 슬라이드가
//             나타나도록 하기위해 우선 맨뒤 li를
//             맨앞으로 이동하고 동시에 left값을
//             -220%로 변경한다.
//             그 후 left값을 0으로 애니메이션하여
//             슬라이드가 왼쪽에서 들어온다.
//         (3) 공통기능: 슬라이드 위치표시 블릿
//             - 블릿 대상: .indic li
//             - 변경 내용: 슬라이드 순번과 같은 순번의
//             li에 클래스 "on"주기(나머진 빼기->초기화!)
// *****************************************************/
// function setBan(obj, seq){ //obj는 최상위 요소 객체
//     /* 1. 호출확인 */
//     console.log("배너야");
//     /* 2. 대상선정: .bancont */
//     const  bancont = obj.querySelector(".bancont");
//     /* 3. 태그 구성하기 */
//     /* 태그 변수 */
//     let hcode = `<ul class="slide">`;
//     /* 배너 종류별 배너 세팅 구분하기 */
//     if(seq === 0){
//         for(let i = 1; i <= 13; i++){
//             hcode += `
//                 <li>
//                     <img src="./nav06/img_nav06/ban${i}.png" alt="배너 이미지">
//                 </li>
//             `;
//         }
//     }else if(seq === 1){
//         for(let i = 1; i <= 6; i++){
//             hcode += `
//                 <li>
//                     <img src="./nav06/img_nav06/sban${i}.jpg" alt="배너 이미지">
//                 </li>
//             `;
//         }
//     }
//     hcode +=`</ul>`;
//     bancont.innerHTML = hcode;
//     // [ 슬라이드 기본기능 구현 ] //////////////////
//     // 1. 대상선정 //////////////////////////
//     // 1-1. 이벤트 대상: .abtn
//     const abtn = obj.querySelectorAll(".abtn");
//     // 1-2. 변경 대상: .slide
//     const slide = obj.querySelector(".slide");
//     // 1-3. 블릿 대상: .indic li
//     // const indic = obj.querySelectorAll(".indic li");
//     // console.log(indic);
//     // 1-4. 슬라이드 li리스트
//     let slist = obj.querySelectorAll(".slide>li");
//     // [ 초기화1 - 순번붙이기 ] ///////////////////
//     // 잘라내기로 li순번이 뒤섞이므로 블릿변경 매칭을 위한
//     // 고유순번을 사용자정의 속성(data-)으로 만들어준다!
//     slist.forEach((ele, idx) => {
//         // data-seq 라는 사용자정의 속성 넣기
//         ele.setAttribute("data-seq", idx);
//     }); ////// forEach /////////////////
//     // [ 초기화2 - 맨뒤요소 맨앞으로 이동 2번하기! ]
//     // 맨뒤 맨앞이동 함수만들기
//     const chgSeq = () => {
//         // 현재 슬라이드 li 새로읽기(2번반복시 li의 순서가 달라지기때문)
//         slist = obj.querySelectorAll(".slide>li");
//         // 맨뒤 맨앞이동하기 -> 변경대상: .slide -> slide변수
//         slide.insertBefore(slist[slist.length - 1], slist[0]);
//         // slide.insertBefore(넣을놈,넣을놈전놈)
//         // slide.insertBefore(마지막요소,첫요소)
//         // slide.insertBefore(slist[개수-1],slist[0]);
//     }; ////////// chgSeq함수 ///////////
//     // 2번 맨뒤 맨앞이동 함수 호출하기!!!
//     for (let i = 0; i < 2; i++) chgSeq();
//     // 광클금지변수 : 0 - 허용, 1 - 불허용
//     let prot = 0;
//     // 2. 슬라이드 변경함수 만들기
//     // 호출시 seq에 들어오는 값중 1은 오른쪽, 0은 왼쪽
//     const goSlide = (seq) => {
//         //  console.log("슬고우!", seq);
//         //  console.log("못들어갔어!!!!");
//         // 광클금지 설정하기 //////
//         if (prot) return;
//         prot = 1; // 잠금!
//         setTimeout(() => {
//             prot = 0; // 해제!
//         }, 400); /// 0.4초후 해제! ///
//         //  console.log("나,들어왔어!!!");
//         // 0. 현재의 슬라이드 li수집하기
//         let clist = slide.querySelectorAll("li");
//         // clist -> current list 현재 리스트
//         // 1. 방향에 따른 분기
//         // 1-1. 오른쪽버튼 클릭시 ////////////////
//         if (seq) {
//             console.log("오른!");
//             // 1. 슬라이드 이동전 먼저 잘라낸다!
//             // 이유: 슬라이드 순서를 왼쪽이동과 동일하게 함!
//             // 중앙확대 트랜지션 적용시 동작이 달라지므로!
//             // (1-1) 바깥에 나가있는 첫번째 슬라이드
//             //       li를 잘라서 맨뒤로 보낸다!
//             slide.appendChild(clist[0]);
//             // (1-2) 동시에 left값을 -120%으로 변경한다!
//             slide.style.left = "-120%";
//             // (1-3) 트랜지션 없애기!
//             slide.style.transition = "none";
//             // (2) 오른쪽 버튼 클릭시 다음 슬라이드가
//             //     나타나도록 슬라이드 박스의 left값을
//             //     -240%로 변경시킨다.
//             // [코드분리하기!] //////////////////////////
//             // -> 같은속성변경을 같은 메모리공간에서 수행하면
//             // 변경효과가 없음!!!
//             setTimeout(() => {
//                 slide.style.left = "-240%";
//                 slide.style.transition = "left .4s ease-in-out";
//             }, 1); //// 타임아웃 //////
//             // 시간에 0을쓰면 인터발호출시 트랜지션이 안먹히는 에러가 있음
//             // 1만써도 괜찮음~
//             // -> 타이밍함수는 기존 함수인 스택(Stack)메모리 공간이 아닌
//             // 대기실행 공간인 큐(Queue)메모리공간에서 실행하므로
//             // 코드가 동시에 바뀌는 것을 막아주고 의도한 대로
//             // 시차실행을 가능하게 해준다!
//         } //////////// if : 오른쪽클릭시 //////
//         // 1-2. 왼쪽버튼 클릭시 //////////////
//         else {
//             console.log("왼쪽!");
//             // (1) 왼쪽버튼 클릭시 이전 슬라이드가
//             // 나타나도록 하기위해 우선 맨뒤 li를
//             // 맨앞으로 이동한다.
//             // slide.insertBefore(넣을놈,넣을놈전놈)
//             // slide.insertBefore(맨끝li,맨앞li)
//             slide.insertBefore(clist[clist.length - 1], clist[0]);
//             // (2) 동시에 left값을 -360%로 변경한다.
//             slide.style.left = "-360%";
//             // 이때 트랜지션을 없앤다(한번실행후 부터 생기므로!)
//             slide.style.transition = "none";
//             // (3) 그 후 left값을 -240%으로 애니메이션하여
//             // 슬라이드가 왼쪽에서 들어온다.
//             // 동일 속성인 left가 같은 코딩처리 공간에 동시에
//             // 있으므로 이것을 분리해야 효과가 있다!
//             // setTimeout을 사용한다!
//             setTimeout(() => {
//                 slide.style.left = "-240%";
//                 slide.style.transition = "left .4s ease-in-out";
//             }, 0); ////// 타임아웃 /////////
//         } //////////// else : 왼쪽클릭시 //////
//         // 2. 현재 슬라이드 순번과 같은 블릿표시하기
//         // 대상: .indic li -> indic변수
//         // 2-1. 현재 배너리스트 업데이트하기
//         // clist = slide.querySelectorAll("li");
//         // !!!!! 오른쪽이든 왼쪽이든 먼저 잘라내기 때문에
//         // 순번은 3번째로 일치함!!!!!!
//         // console.log("다시수집:",clist);
//         // 2-2.방향별 읽어올 슬라이드 순번으로 "data-seq"값 읽어오기
//         // 세번째 슬라이드가 주인공이니까 0,1,2 즉 2번을 쓰면됨!!!
//         // let cseq = clist[2].getAttribute("data-seq");
//         //  console.log("현재순번:", cseq);
//         // 2-3. 블릿초기화
//         // for (let x of indic) x.classList.remove("on");
//         // 2-4. 읽어온 슬라이드 순번의 블릿에 클래스 "on"넣기
//         // indic[cseq].classList.add("on");
//     }; ////////// goSlide함수 ///////////
//     // 3. 이동버튼대상에 이벤트 설정하기
//     abtn.forEach((ele, idx) => {
//         ele.onclick = () => {
//             // 0. 기본이동막기
//             event.preventDefault();
//             // 1. 인터발지우기함수 호출!
//             // clearAuto();
//             // 2. 슬라이드 함수 호출!
//             goSlide(idx);
//         }; ///// click함수 //////
//     }); /////// forEach //////////
//     ////////////////////////////
//     // 자동넘김 설정하기 ////////
//     // 일정시간간격 넘어가기
//     // -> setInterval(함수,시간)
//     // [인터발함수의 함수전달값 사용예
//     // (타임아웃함수도 동일함)]
//     // 1. 함수에 전달값이 없으면 함수명만 사용가능
//     // setInterval(goSlide,3000);
//     // 2. 전달값이 있다면 익명함수구역에 코딩
//     // setInterval(function(){goSlide(1)},3000);
//     // 3. 화살표함수사용가능
//     // setInterval(()=>{goSlide(1)},3000);
//     // 4. 화살표함수에서 중괄호 생략가능
//     // setInterval(()=>goSlide(1),3000);
//     // 인터발함수 지우기위한 변수
//     let autoI;
//     // 타임아웃함수 지우기위한 변수
//     let autoT;
//     /************************************ 
//         함수명: autoSlide
//         기능: 인터발함수로 슬라이드함수 호출
//     ************************************/
//     function autoSlide() {
//         console.log("인터발시작!");
//         // 인터발함수로 슬라이드함수 호출하기
//         autoI = setInterval(() => goSlide(1), 3000);
//     } ////////////// autoSlide함수 //////////
//     // 자동넘김 최초호출!
//     // autoSlide();
//     /************************************ 
//         함수명: clearAuto
//         기능: 인터발함수를 지우고 다시셋팅
//    ************************************/
//     function clearAuto() {
//         console.log("인터발멈춤!");
//         // 1. 인터발 지우기
//         clearInterval(autoI);
//         // 2. 타임아웃도 지우지 않으면
//         // 쌓여서 타임아웃 쓰나미실행이 발생한다!
//         clearTimeout(autoT);
//         // 3. 잠시후 다시 작동하도록 타임아웃으로
//         // 인터발함수를 호출한다!
//         // 5초후(인터발은 3초후, 토탈 8초후 작동시작)
//         autoT = setTimeout(autoSlide, 5000);
//     } ///////// clearAuto 함수 /////////////
// } //////////////// loadFn 함수 ///////////////
// /////////////////////////////////////////////
